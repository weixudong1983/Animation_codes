0:00
让我们以**斐波那契数列**为例来理解**动态规划**。斐波那契数列是一系列数字，从 **0** 和 **1** 开始，每个后续数字是前两个数字的和。所以下一个数字将是 **0** 和 **1** 的和，也就是 **1**，然后下一个数字将是 **1** 和 **1** 的和，也就是 **2**，依此类推。
0:12
数学上可以表示为 **f(n) = f(n - 1) + f(n - 2)**，初始值是 **f(0) = 0** 且 **f(1) = 1**。
0:18
现在，在使用**动态规划**技术进行优化之前，我们先来看一种简单但低效的方法。我们首先定义一个函数，它有一个参数 **n**。如果 **n <= 1**，我们直接返回 **n** 来处理基本情况。
0:25
否则，我们递归地计算 **f(n - 1) + f(n - 2)**。乍一看，这似乎可行。如果我们对像 **n = 5** 这样的小值运行代码，它会很快给出输出。但对于像 **n = 100** 这样的大值，程序执行需要极长的时间。在我的测试中，我不得不终止程序，因为它一直无法完成。
0:38
问题是为什么会这样呢？让我们通过绘制其**递归树**来分析这个问题。以 **n = 5** 为例，要计算 **f(5)**，我们需要它前面的两个值 **f(4)** 和 **f(3)**。而这两个值又分别需要它们各自的前两个值。这个过程会一直持续，直到初始值。
0:44
相同计算在不同分支的树中被多次重复。例如，**f(3)** 和 **f(2)** 在树的不同分支中会被反复计算。这种冗余就是我们简单的递归代码运行缓慢的原因。它没有利用之前已经计算好的结果，而是不必要地重新计算它们，导致了**指数级**时间复杂度。
0:56
为了更高效地解决这个问题，我们需要一种方法来存储并重用已经计算过的值。这就是**动态规划**发挥作用的地方。
1:02
首先，让我们看看一种称为“**记忆化（Memoization）**”的**自顶向下**优化方法。我们首先初始化一个大小为 **n + 1** 的数组，并将所有值设置为 **-1**。这表示这些索引处的值尚未计算。
1:07
现在，我们开始计算 **f(5)**。该索引的值是 **-1**，意味着我们需要先计算 **f(4)** 和 **f(3)**。接着看 **f(3)**，索引 **3** 的值也是 **-1**。所以我们进一步将其分解为 **f(2)** 和 **f(1)**。**f(1)** 是基本情况，所以我们将数组中索引 **1** 的值更新为 **1**。
1:14
再看 **f(2)**，它的值仍然是 **-1**。所以我们进一步将其分解为 **f(1)** 和 **f(0)**。**f(0)** 是另一个基本情况，所以我们将索引 **0** 的值更新为 **0**。然后我们计算 **f(2) = f(1) + f(0)**，也就是 **1**。于是我们将它存储在索引 **2** 处。
1:20
类似地，我们计算 **f(3) = f(2) + f(1)**，结果是 **2**，我们将它更新到索引 **3** 处。
1:26
接着我们回到 **f(5)**，发现还需要 **f(4)**。但这里就是优化之处了：我们不需要重新计算 **f(3)** 和 **f(2)**，因为它们已经存储在数组中了。我们只需获取它们的值，然后计算 **f(4) = 3**，并将它存储在索引 **4** 处。
1:32
最后，我们计算 **f(5) = f(4) + f(3)**，结果是 **5**。
1:38
请记住，我们从 **f(5)** 开始，逐步向下计算到基本情况，然后利用存储的值来计算更大的值。这就是为什么**记忆化**遵循**自顶向下**的方法。
1:44
接下来，让我们看看这种方法的代码实现。首先我们定义一个函数，它接收两个参数：**n** 和一个用于存储预先计算值的数组（初始化为 **-1**）。在函数内部，我们首先检查索引 **n** 处的值是否不是 **-1**。如果不是 **-1**，就意味着该值已经被计算过了，所以我们直接返回它。
1:50
接下来我们检查基本情况。如果 **n <= 1**，我们将索引 **n** 处的值设置为 **n** 并返回它。
1:56
否则，我们递归地计算该值（将前面两个已计算的值相加），并将结果存储在数组中。
2:03
最后，我们可以选择一个测试值 **n**，初始化一个所有元素都设为 **-1** 的数组，然后调用该函数。
2:09
如果我们使用 **n = 100** 运行这段代码，它会立即给出输出。
2:16
接下来，让我们探讨另一种技术：**表格法（Tabulation）**。这是一种**自底向上**的方法，我们从基本情况开始构建解决方案，而不是通过递归求解。
2:22
首先，我们初始化一个大小为 **n + 1** 的数组，所有元素初始值都设为 **0**。数组的前两个元素设置为 **0** 和 **1**，代表基本情况。
2:28
然后，我们从索引 **2** 开始，使用一个指针 **i**，迭代地计算每个斐波那契数，方法是将前两个值相加并更新当前索引的值。这个过程一直持续到我们计算到第 **n** 个值为止。
2:36
这种方法采用迭代方式，通常比**记忆化**方法更直观。
2:44
注意一点：我们是从 **fib(0)** 开始，然后到 **fib(1)**，一直到 **fib(n)**。这就是为什么这种方法被称为**自底向上**方法的原因。
2:50
该方法的代码很简单。首先我们定义一个接收 **n** 作为输入的函数。然后，我们像往常一样检查基本情况。接下来，我们初始化一个数组，并将索引 **0** 和索引 **1** 的元素设置为基本情况对应的值。
2:56
之后，我们从第二个索引开始运行一个循环，通过将前两个元素相加来更新每个索引的值。
3:02
最后，我们返回索引 **n** 处的值，它给出了该位置对应的斐波那契数。
3:08
因此，通过这个例子，我们对**动态规划**有了基本的了解。简而言之，它是一种优化技术，将问题分解为更简单的、**重叠的子问题**，然后存储并重用这些子问题的解以提高效率。
3:14
现在，它主要有两种方法：一种是**记忆化**，这是一种**自顶向下**的方法，使用递归；另一种是**表格法**，这是一种**自底向上**的方法，使用迭代。
3:20
动态规划要适用，一个问题必须满足两个条件：一是存在**重叠子问题**（我们在前面已经看到了），另一个叫做**最优子结构**，意思是问题可以分解为可独立求解的子问题，然后将这些子问题的解组合起来形成最终解。
3:26
在这个视频中，我们探讨了**斐波那契数**问题以及如何使用**动态规划**对其进行优化。在接下来的几个视频中，我们将深入研究一些最著名的**动态规划**问题，并通过可视化方式对它们进行拆解，以便更好地理解。