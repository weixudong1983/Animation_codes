栈是一种非常特别的数据结构。
它遵循一个重要的原则——“后进先出”。

这是什么意思呢？
就是最后放进去的元素，会最先被取出来。
谁后来进去，谁先出来！

虽然这个规则听起来简单，
但“栈”却是计算机世界中最常见、最重要的结构之一。
在很多地方，我们都能看到它的身影：
比如函数调用栈、撤销操作、括号匹配，
甚至在深度优先搜索这样的算法里，
也都离不开它的帮助。

想象一下你在厨房里收拾碗盘。
你一只一只地往上叠盘子，
第一个盘子在最底下，
后面放的盘子一层层堆上去。

可当你要拿盘子时，
是不是总是先拿最上面的那一个？ 
下面的盘子要等上面的拿走之后才能取出来。

程序中的“栈”（stack）就是这样工作的：
最后放进去的，总是最先被取出来。
这就是“后进先出”的意思！

向栈里添加一个新元素，
我们称之为**“入栈（push）”。
当一个元素被压入栈中，
它就会被放在最顶端——也就是栈顶**的位置。

从栈中取出一个元素，
我们称之为**“出栈（pop）”**。
当一个元素被弹出时，
它会从栈顶被移除，
然后下面的那个元素，
就会成为新的栈顶。

如果所有元素都被弹出了，
那么栈就变成了空栈。
这时如果还要继续“出栈”，
程序就会报错，
这种错误叫做**“栈下溢”**。

反过来，如果不断往栈里压入新元素，
超过了它的最大容量，
程序也会报错，
这种情况叫做**“栈溢出”**。

栈看起来只是“放”和“取”那么简单，
但它是计算机运算的基础工具之一。
正是因为有了它，
程序才能有条不紊地执行，
就像一摞叠得整整齐齐的盘子一样，
井井有条、秩序分明！




栈可以通过两种方式实现：
一种是使用数组，
另一种是使用链表。
我们先从数组的实现方式开始。



首先定义一个名为 Stack 的类。

并初始化三个成员变量：
data 用于存放元素；
top 表示当前元素数量；
capacity 表示栈的最大容量。
在构造函数中，
我们设定默认容量为 6。

我们先看两个辅助函数为空和为满
当top 等于-1 
则栈表示空
当 top的索引为 capacity 时
则栈表示满

接着定义两个主要操作：
push（入栈）和 pop（出栈）。

push 方法用于向栈中添加元素。
它会先判断栈是否已满。
如果 top 等于 capacity - 1，
则抛出“栈上溢”错误。
否则将新元素加入 data 数组末尾，
并让 top 加 1。

pop 方法用于移除栈顶元素。
它先检查栈是否为空。
如果 为空，
则抛出“栈下溢”错误。
否则 top 减 1，
并删除并返回数组最后一个元素。

还有一个 peek 方法。
它用来查看栈顶元素，
但不会修改栈的内容。
peek 首先判断栈是否为空。
若为空则抛出下溢错误，
否则返回栈顶的值。




接下来我们用动画演示代码运行过程。
首先创建一个 Stack 对象。
栈的容量默认是 6。
中间显示的是抽象的栈结构，
右边的数组则表示实际存储。

初始化完成后，
我们向栈中压入几个元素。
入栈操作相当于在数组末尾追加数据，
这是一个常数时间操作。

peek 操作会返回栈顶元素，
也就是数组的最后一个元素。
它同样只需常数时间完成。

当执行出栈操作时，
会删除数组末尾的元素。
这也是一个常数时间操作。



接下来我们看
用链表实现的栈。

在链表的栈里，
栈顶是链表的头节点，
栈底是链表的尾节点。

出栈时，
我们把头节点删除；
入栈时，
我们在头部插入新节点。

先来定义一个 Node 类，
用来保存数据和下一个节点的指针。
指针就像一支小箭头，
指向下一个节点在内存里的“位置”。

接着定义 Stack 类，
用一个叫 top 的指针保存链表头。
初始化时，top 是空的（null）。
同时我们用 count 记录当前大小。

先写两个辅助函数：
isEmpty() 和 isFull()。
如果 top 为 null，说明栈是空的。
链表栈通常不会返回“满”，
因为只要还有内存，
就可以继续添加元素。

接下来定义三个主要操作：
push（压栈）、pop（弹栈） 和 peek（查看）。

push 操作：

1. 接收一个要压入的值。
2. 创建一个新的 Node 节点。
3. 让新节点的 next 指向当前的 top。
4. 更新 top 指向这个新节点。
（新节点变成了新的栈顶）


pop 操作：

1. 先判断栈是否为空。
2. 若为空，就报“栈下溢”错误。
3. 若不为空，先把当前 top 暂存起来。
4. 把 top 更新为 top.next（也就是下一个节点）。
5. 返回原来保存在暂存节点的值，
并释放那个节点。


peek 操作：
只看一看 top 的值，
不删除节点，
用来查看当前栈顶是什么。

用动画来演示时，
你会看到入栈和出栈时，
链表头部的指针在变化。
这两种操作都是常数时间，
也就是说速度很快，效率高。

请仔细观察动画，
结合代码去理解 top 指针
是如何移动的。