[00:00.00] 栈是一种非常特别的数据结构。
[00:03.50] 它遵循一个重要的原则——“后进先出”。
[00:10.25] 这是什么意思呢？
[00:12.25] 就是最后放进去的元素，会最先被取出来。
[00:17.00] 谁后来进去，谁先出来！
[00:21.75] 虽然这个规则听起来简单，
[00:24.75] 但“栈”却是计算机世界中最常见、最重要的结构之一。
[00:31.00] 在很多地方，我们都能看到它的身影：
[00:35.25] 比如函数调用栈、撤销操作、括号匹配，
[00:39.75] 甚至在深度优先搜索这样的算法里，
[00:43.75] 也都离不开它的帮助。
[00:48.25] 想象一下你在厨房里收拾碗盘。
[00:51.75] 你一只一只地往上叠盘子，
[00:54.75] 第一个盘子在最底下，
[00:57.25] 后面放的盘子一层层堆上去。
[01:02.50] 可当你要拿盘子时，
[01:04.75] 是不是总是先拿最上面的那一个？ 
[01:08.75] 下面的盘子要等上面的拿走之后才能取出来。
[01:15.75] 程序中的“栈”（stack）就是这样工作的：
[01:21.25] 最后放进去的，总是最先被取出来。
[01:25.25] 这就是“后进先出”的意思！
[01:30.50] 向栈里添加一个新元素，
[01:33.25] 我们称之为**“入栈（push）”。
[01:37.75] 当一个元素被压入栈中，
[01:40.50] 它就会被放在最顶端——也就是栈顶**的位置。
[01:48.00] 从栈中取出一个元素，
[01:50.50] 我们称之为**“出栈（pop）”**。
[01:55.25] 当一个元素被弹出时，
[01:57.75] 它会从栈顶被移除，
[02:00.00] 然后下面的那个元素，
[02:02.50] 就会成为新的栈顶。
[02:06.75] 如果所有元素都被弹出了，
[02:09.75] 那么栈就变成了空栈。
[02:12.25] 这时如果还要继续“出栈”，
[02:15.50] 程序就会报错，
[02:17.25] 这种错误叫做**“栈下溢”**。
[02:23.25] 反过来，如果不断往栈里压入新元素，
[02:27.50] 超过了它的最大容量，
[02:30.00] 程序也会报错，
[02:31.75] 这种情况叫做**“栈溢出”**。
[02:37.75] 栈看起来只是“放”和“取”那么简单，
[02:42.25] 但它是计算机运算的基础工具之一。
[02:46.25] 正是因为有了它，
[02:48.25] 程序才能有条不紊地执行，
[02:51.25] 就像一摞叠得整整齐齐的盘子一样，
[02:55.25] 井井有条、秩序分明！
[03:05.75] 栈可以通过两种方式实现：
[03:08.75] 一种是使用数组，
[03:10.75] 另一种是使用链表。
[03:13.00] 我们先从数组的实现方式开始。
[03:22.50] 首先定义一个名为 Stack 的类。
[03:29.00] 并初始化三个成员变量：
[03:31.75] data 用于存放元素；
[03:34.75] top 表示当前元素数量；
[03:38.00] capacity 表示栈的最大容量。
[03:42.50] 在构造函数中，
[03:44.25] 我们设定默认容量为 6。
[03:49.25] 我们先看两个辅助函数为空和为满
[03:53.00] 当top 等于-1 
[03:55.50] 则栈表示空
[03:56.75] 当 top的索引为 capacity 时
[04:01.75] 则栈表示满
[04:05.00] 接着定义两个主要操作：
[04:07.75] push（入栈）和 pop（出栈）。
[04:14.25] push 方法用于向栈中添加元素。
[04:18.50] 它会先判断栈是否已满。
[04:21.25] 如果 top 等于 capacity - 1，
[04:27.00] 则抛出“栈上溢”错误。
[04:29.75] 否则将新元素加入 data 数组末尾，
[04:34.50] 并让 top 加 1。
[04:39.25] pop 方法用于移除栈顶元素。
[04:43.00] 它先检查栈是否为空。
[04:45.50] 如果 为空，
[04:47.00] 则抛出“栈下溢”错误。
[04:49.75] 否则 top 减 1，
[04:52.50] 并删除并返回数组最后一个元素。
[04:58.25] 还有一个 peek 方法。
[05:01.50] 它用来查看栈顶元素，
[05:04.00] 但不会修改栈的内容。
[05:06.50] peek 首先判断栈是否为空。
[05:10.25] 若为空则抛出下溢错误，
[05:13.00] 否则返回栈顶的值。
[05:23.25] 接下来我们用动画演示代码运行过程。
[05:27.50] 首先创建一个 Stack 对象。
[05:31.50] 栈的容量默认是 6。
[05:34.00] 中间显示的是抽象的栈结构，
[05:37.25] 右边的数组则表示实际存储。
[05:42.50] 初始化完成后，
[05:44.25] 我们向栈中压入几个元素。
[05:47.25] 入栈操作相当于在数组末尾追加数据，
[05:51.50] 这是一个常数时间操作。
[05:56.25] peek 操作会返回栈顶元素，
[06:00.00] 也就是数组的最后一个元素。
[06:03.25] 它同样只需常数时间完成。
[06:08.25] 当执行出栈操作时，
[06:10.50] 会删除数组末尾的元素。
[06:13.25] 这也是一个常数时间操作。
[06:22.25] 接下来我们看
[06:23.75] 用链表实现的栈。
[06:27.75] 在链表的栈里，
[06:29.50] 栈顶是链表的头节点，
[06:32.00] 栈底是链表的尾节点。
[06:36.50] 出栈时，
[06:37.50] 我们把头节点删除；
[06:39.75] 入栈时，
[06:40.75] 我们在头部插入新节点。
[06:45.50] 先来定义一个 Node 类，
[06:49.00] 用来保存数据和下一个节点的指针。
[06:53.00] 指针就像一支小箭头，
[06:55.50] 指向下一个节点在内存里的“位置”。
[07:01.75] 接着定义 Stack 类，
[07:05.00] 用一个叫 top 的指针保存链表头。
[07:09.50] 初始化时，top 是空的（null）。
[07:14.25] 同时我们用 count 记录当前大小。
[07:21.00] 先写两个辅助函数：
[07:23.25] isEmpty() 和 isFull()。
[07:28.50] 如果 top 为 null，说明栈是空的。
[07:33.75] 链表栈通常不会返回“满”，
[07:37.00] 因为只要还有内存，
[07:39.25] 就可以继续添加元素。
[07:43.75] 接下来定义三个主要操作：
[07:46.75] push（压栈）、pop（弹栈） 和 peek（查看）。
[07:55.75] push 操作：
[07:59.75] 1. 接收一个要压入的值。
[08:03.00] 2. 创建一个新的 Node 节点。
[08:07.50] 3. 让新节点的 next 指向当前的 top。
[08:13.50] 4. 更新 top 指向这个新节点。
[08:18.00] （新节点变成了新的栈顶）
[08:25.00] pop 操作：
[08:28.75] 1. 先判断栈是否为空。
[08:31.75] 2. 若为空，就报“栈下溢”错误。
[08:36.00] 3. 若不为空，先把当前 top 暂存起来。
[08:41.50] 4. 把 top 更新为 top.next（也就是下一个节点）。
[08:49.50] 5. 返回原来保存在暂存节点的值，
[08:53.75] 并释放那个节点。
[08:59.75] peek 操作：
[09:01.75] 只看一看 top 的值，
[09:04.75] 不删除节点，
[09:06.25] 用来查看当前栈顶是什么。
[09:11.25] 用动画来演示时，
[09:13.25] 你会看到入栈和出栈时，
[09:16.00] 链表头部的指针在变化。
[09:18.75] 这两种操作都是常数时间，
[09:21.75] 也就是说速度很快，效率高。
[09:27.00] 请仔细观察动画，
[09:29.00] 结合代码去理解 top 指针
[09:32.50] 是如何移动的。