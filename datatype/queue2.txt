我们用循环队列来避免数组空间被浪费。
这里有两个关键指针：front 和 rear。
它们在初始化时都设为 0。
队列中的有效数据，
是从 front 位置 到 rear 位置（不包含 rear） 之间的部分。
为了防止“满队列”和“空队列”难以区分，
我们会多留一个位置不放数据，
这样队列的容量计算就会更准确。  


插入第一个元素时，
front 指针保持不动，
rear 指针先在当前位置放入数据，
然后再向右移动一位。





之后每次入队操作时，
front 指针依旧保持不动，
rear 指针向右移动到下一个位置，
新的元素就会依次存放在这些位置中。





当执行出队操作时，
front 位置的元素会被设为 0。
接着 front 指针右移一位。
虽然把值设为 0 并不是必须的，
但通常这样做能让结构更清晰，
避免混淆，是一种良好的编程习惯。













循环队列的真正优势在于，
当 rear 指针移动到数组末尾时，
它不会停下，也不会浪费空间，
而是“回绕”到数组的起始位置。
这样，队列就能继续利用之前释放的空间。

当 rear 指针移动到 front 前一个位置时，
也就是 (rear + 1) == front 的时候，
队列就被认为是“已满”。
此时不能再插入新元素，
否则新数据会覆盖掉 front 位置的内容。




在代码实现部分，
我们首先定义了一个名为 CircularQueue 的类。
接着，定义了几个成员变量，
用于存放队列的数据、容量，以及 front 和 rear 两个指针。
在类的构造函数中，
我们只需要传入一个参数 —— 容量 n，
它决定了队列最多可以存放多少个元素。
在初始化这些成员变量时，
我们使用了 构造函数初始化列表 的写法。
这和在构造函数体内赋值的效果是一样的，
但写在初始化列表中更加 简洁、高效，也更符合 C++ 的规范。








接着初始化类的成员变量。
首先把 capacity（容量）设置为 n + 1，
因为我们需要额外预留一个空位。
然后创建一个大小为 n + 1 的数组 data。
最后把 front 和 rear 两个指针都初始化为 0，
表示队列此时是空的。



接下来，我们定义一个函数，
用于判断队列是否已满。
当 rear 指针正好在 front 前一个位置时，
队列被视为“已满”，函数返回 true，
否则返回 false。

举个例子：
假设队列的逻辑大小是 6，
则数组的实际容量是 7。
如果 rear 在索引 1，front 在索引 2，
根据判断公式，队列就是满的。
相反，如果 rear 在索引 0，
则返回 false，说明队列未满。




然后我们实现一个函数，
判断队列是否为空。
它只需要检查 front 是否等于 rear。
如果二者相等，表示队列为空；
否则说明队列中存在元素。

完成这些基础函数后，
我们开始实现循环队列的主要操作方法。

入队（enqueue）函数接收一个值作为参数。
首先检查队列是否已满。
如果已满，则输出提示信息并返回。
如果未满，则将新值写入 rear 位置。
随后更新 rear 指针，向右移动一位。
如果移动后的位置超过最大下标，
则通过取余运算让它回到数组起点，
就像在环形赛道上循环前进一样。



出队（dequeue）函数的逻辑与此类似。
它首先检查队列是否为空。
如果为空，则打印提示并返回 0。
如果不为空，
则更新 front 指针，向右移动一位。
同样需要检查 front 是否越界，
如果超过容量上限，同样通过取余来回绕。

printQueue 函数用于打印当前队列内容。
如果 rear 大于或等于 front，
说明队列元素在数组中是连续的，
可以直接打印 front 到 rear 之间的所有元素。
如果 rear 小于 front，
说明队列被“分割”成两部分。
这时先输出 front 到数组末尾的部分，
再输出从数组开头到 rear 的部分。
由于对索引取余，
当指针到达末尾后会自动回到索引 0，
从而实现循环遍历的效果。

下面，我们通过一组示例数据，
演示循环队列的入队和出队操作过程。