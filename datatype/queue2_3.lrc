[00:00.00] 我们用循环队列来避免数组空间被浪费。
[00:03.60] 这里有两个关键指针：front 和 rear。
[00:08.19] 它们在初始化时都设为 0。
[00:10.79] 队列中的有效数据，
[00:12.59] 是从 front 位置 到 rear 位置（不包含 rear） 之间的部分。
[00:20.19] 为了防止“满队列”和“空队列”难以区分，
[00:24.19] 我们会多留一个位置不放数据，
[00:27.00] 这样队列的容量计算就会更准确。  
[00:34.39] 插入第一个元素时，
[00:36.19] front 指针保持不动，
[00:38.79] rear 指针先在当前位置放入数据，
[00:42.39] 然后再向右移动一位。
[00:46.39] 之后每次入队操作时，
[00:48.39] front 指针依旧保持不动，
[00:51.39] rear 指针向右移动到下一个位置，
[00:55.00] 新的元素就会依次存放在这些位置中。
[01:00.39] 当执行出队操作时，
[01:02.19] front 位置的元素会被设为 0。
[01:05.79] 接着 front 指针右移一位。
[01:09.00] 虽然把值设为 0 并不是必须的，
[01:12.20] 但通常这样做能让结构更清晰，
[01:15.00] 避免混淆，是一种良好的编程习惯。
[01:20.20] 循环队列的真正优势在于，
[01:22.60] 当 rear 指针移动到数组末尾时，
[01:26.20] 它不会停下，也不会浪费空间，
[01:29.00] 而是“回绕”到数组的起始位置。
[01:32.00] 这样，队列就能继续利用之前释放的空间。
[01:37.79] 当 rear 指针移动到 front 前一个位置时，
[01:43.00] 也就是 (rear + 1) == front 的时候，
[01:48.59] 队列就被认为是“已满”。
[01:51.00] 此时不能再插入新元素，
[01:53.20] 否则新数据会覆盖掉 front 位置的内容。
[01:59.60] 在代码实现部分，
[02:01.20] 我们首先定义了一个名为 CircularQueue 的类。
[02:07.00] 接着，定义了几个成员变量，
[02:09.59] 用于存放队列的数据、容量，以及 front 和 rear 两个指针。
[02:16.40] 在类的构造函数中，
[02:18.20] 我们只需要传入一个参数 —— 容量 n，
[02:22.20] 它决定了队列最多可以存放多少个元素。
[02:25.80] 在初始化这些成员变量时，
[02:28.20] 我们使用了 构造函数初始化列表 的写法。
[02:32.20] 这和在构造函数体内赋值的效果是一样的，
[02:36.00] 但写在初始化列表中更加 简洁、高效，也更符合 C++ 的规范。
[02:46.20] 接着初始化类的成员变量。
[02:48.60] 首先把 capacity（容量）设置为 n + 1，
[02:53.80] 因为我们需要额外预留一个空位。
[02:56.80] 然后创建一个大小为 n + 1 的数组 data。
[03:01.80] 最后把 front 和 rear 两个指针都初始化为 0，
[03:07.60] 表示队列此时是空的。
[03:11.60] 接下来，我们定义一个函数，
[03:14.20] 用于判断队列是否已满。
[03:16.40] 当 rear 指针正好在 front 前一个位置时，
[03:21.59] 队列被视为“已满”，函数返回 true，
[03:25.59] 否则返回 false。
[03:29.79] 举个例子：
[03:30.79] 假设队列的逻辑大小是 6，
[03:33.39] 则数组的实际容量是 7。
[03:35.79] 如果 rear 在索引 1，front 在索引 2，
[03:40.99] 根据判断公式，队列就是满的。
[03:43.79] 相反，如果 rear 在索引 0，
[03:47.19] 则返回 false，说明队列未满。
[03:52.59] 然后我们实现一个函数，
[03:54.79] 判断队列是否为空。
[03:56.59] 它只需要检查 front 是否等于 rear。
[04:01.19] 如果二者相等，表示队列为空；
[04:04.00] 否则说明队列中存在元素。
[04:08.40] 完成这些基础函数后，
[04:10.40] 我们开始实现循环队列的主要操作方法。
[04:16.00] 入队（enqueue）函数接收一个值作为参数。
[04:20.60] 首先检查队列是否已满。
[04:22.80] 如果已满，则输出提示信息并返回。
[04:26.00] 如果未满，则将新值写入 rear 位置。
[04:30.00] 随后更新 rear 指针，向右移动一位。
[04:34.00] 如果移动后的位置超过最大下标，
[04:37.00] 则通过取余运算让它回到数组起点，
[04:40.19] 就像在环形赛道上循环前进一样。
[04:45.19] 出队（dequeue）函数的逻辑与此类似。
[04:49.39] 它首先检查队列是否为空。
[04:51.79] 如果为空，则打印提示并返回 0。
[04:54.99] 如果不为空，
[04:56.19] 则更新 front 指针，向右移动一位。
[05:00.19] 同样需要检查 front 是否越界，
[05:03.79] 如果超过容量上限，同样通过取余来回绕。
[05:09.59] printQueue 函数用于打印当前队列内容。
[05:14.39] 如果 rear 大于或等于 front，
[05:18.39] 说明队列元素在数组中是连续的，
[05:21.39] 可以直接打印 front 到 rear 之间的所有元素。
[05:27.00] 如果 rear 小于 front，
[05:30.39] 说明队列被“分割”成两部分。
[05:33.19] 这时先输出 front 到数组末尾的部分，
[05:37.39] 再输出从数组开头到 rear 的部分。
[05:41.19] 由于对索引取余，
[05:42.80] 当指针到达末尾后会自动回到索引 0，
[05:46.40] 从而实现循环遍历的效果。
[05:50.80] 下面，我们通过一组示例数据，
[05:53.60] 演示循环队列的入队和出队操作过程。